{"version":3,"sources":["Snake.js","GameBoard.js","App.js","reportWebVitals.js","index.js"],"names":["Snake","_ref","snakeSegments","React","createElement","map","segment","index","key","className","style","top","y","left","x","GameBoard","gridSize","segmentSize","setSnakeSegments","useState","food","setFood","generateFoodPosition","score","setScore","gameOver","setGameOver","direction","setDirection","speed","setSpeed","initialSnake","Math","floor","random","useEffect","handleKeyPress","e","document","addEventListener","removeEventListener","timer","setInterval","newSnakeSegments","head","segments","prevScore","prevSpeed","max","clearInterval","body","slice","some","onClick","restartGame","Fragment","Array","_","App","reportWebVitals","onPerfEntry","Function","__webpack_require__","then","bind","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","createRoot","getElementById","render","StrictMode"],"mappings":"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","file":"static/js/main.5b04dff3.chunk.js","sourcesContent":["// src/Snake.js\n\nimport React from 'react';\nimport './Snake.css';\n\nconst Snake = ({ snakeSegments }) => {\n  return (\n    <div>\n      {snakeSegments.map((segment, index) => (\n        <div key={index} className=\"snake-segment\" style={{ top: segment.y, left: segment.x }} />\n      ))}\n    </div>\n  );\n};\n\nexport default Snake;\n","// src/GameBoard.js\n\nimport React, { useState, useEffect } from 'react';\nimport './GameBoard.css';\nimport Snake from './Snake.js';\nimport './Food.css'; // Import the Food.css file\n\nconst GameBoard = () => {\n  const gridSize = 10; // Adjust based on the grid size\n  const segmentSize = 30; // Adjust based on the desired size of each segment\n  const [snakeSegments, setSnakeSegments] = useState([{ x: 0, y: 0 }]);\n  const [food, setFood] = useState(generateFoodPosition());\n  const [score, setScore] = useState(0);\n  const [gameOver, setGameOver] = useState(false);\n  const [direction, setDirection] = useState('RIGHT');\n  const [speed, setSpeed] = useState(200); // Adjust the initial speed\n  const initialSnake = [{ x: 0, y: 0 }];\n\n  function generateFoodPosition() {\n    const x = Math.floor(Math.random() * gridSize) * segmentSize;\n    const y = Math.floor(Math.random() * gridSize) * segmentSize;\n    return { x, y };\n  }\n\n  useEffect(() => {\n    const handleKeyPress = (e) => {\n      switch (e.key) {\n        case 'ArrowUp':\n          setDirection('UP');\n          break;\n        case 'ArrowDown':\n          setDirection('DOWN');\n          break;\n        case 'ArrowLeft':\n          setDirection('LEFT');\n          break;\n        case 'ArrowRight':\n          setDirection('RIGHT');\n          break;\n        default:\n          break;\n      }\n    };\n\n    document.addEventListener('keydown', handleKeyPress);\n\n    return () => {\n      document.removeEventListener('keydown', handleKeyPress);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (gameOver) {\n      return;\n    }\n\n    const timer = setInterval(() => {\n      const newSnakeSegments = snakeSegments.map((segment, index) => {\n        if (index === 0) {\n          switch (direction) {\n            case 'UP':\n              return { x: segment.x, y: segment.y - segmentSize };\n            case 'DOWN':\n              return { x: segment.x, y: segment.y + segmentSize };\n            case 'LEFT':\n              return { x: segment.x - segmentSize, y: segment.y };\n            case 'RIGHT':\n              return { x: segment.x + segmentSize, y: segment.y };\n            default:\n              return segment;\n          }\n        } else {\n          return snakeSegments[index - 1];\n        }\n      });\n\n      // Check for collision with food\n      const head = newSnakeSegments[0];\n      if (head.x === food.x && head.y === food.y) {\n        setFood(generateFoodPosition());\n        // Increase the length of the snake\n        setSnakeSegments((segments) => [\n          head,\n          ...segments,\n        ]);\n        setScore((prevScore) => prevScore + 1);\n        setSpeed((prevSpeed) => Math.max(100, prevSpeed - 10));\n      } else {\n        // If no collision with food, update the snake normally\n        setSnakeSegments(newSnakeSegments);\n      }\n    }, speed);\n\n    return () => {\n      clearInterval(timer);\n    };\n  }, [direction, gameOver, snakeSegments, speed, food, segmentSize]);\n\n  useEffect(() => {\n    if (snakeSegments[0].x === food.x && snakeSegments[0].y === food.y) {\n      setFood(generateFoodPosition());\n      setSnakeSegments((segments) => [\n        { x: segments[0].x, y: segments[0].y },\n        ...segments,\n      ]);\n      setScore((prevScore) => prevScore + 1);\n\n      setSpeed((prevSpeed) => Math.max(100, prevSpeed - 10));\n    }\n\n    const head = snakeSegments[0];\n    const body = snakeSegments.slice(1);\n\n    if (\n      head.x < 0 ||\n      head.x >= gridSize * segmentSize ||\n      head.y < 0 ||\n      head.y >= gridSize * segmentSize ||\n      body.some((segment) => segment.x === head.x && segment.y === head.y)\n    ) {\n      setGameOver(true);\n      setSnakeSegments(initialSnake);\n      setFood(generateFoodPosition());\n      // Update the score directly without resetting it\n      setSpeed(200);\n    }\n  }, [snakeSegments, food, gridSize, score, speed, initialSnake]);\n\n  const restartGame = () => {\n    setSnakeSegments([{ x: 0, y: 0 }]);\n    setFood(generateFoodPosition());\n    setScore(0);\n    setGameOver(false);\n    setDirection('RIGHT');\n    setSpeed(200);\n  };\n\n  return (\n    <div className=\"game-board\">\n      {gameOver ? (\n        <div className=\"game-over-screen\">\n          <h2>Game Over!</h2>\n          {/* Display the updated score directly */}\n          <p>Your score: {score}</p>\n          <button onClick={restartGame}>Play Again</button>\n        </div>\n      ) : (\n        <>\n          <div className=\"score\">Score: {score}</div>\n          <div className=\"grid\">\n            {[...Array(gridSize * gridSize)].map((_, index) => (\n              <div key={index} className=\"cell\" />\n            ))}\n          </div>\n          <Snake snakeSegments={snakeSegments} />\n          <div className=\"food\" style={{ top: food.y, left: food.x }} />\n        </>\n      )}\n    </div>\n  );\n};\n\nexport default GameBoard;\n","// src/App.js\n\nimport React from 'react';\nimport GameBoard from './GameBoard';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <GameBoard />\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nconst root = ReactDOM.createRoot(document.getElementById('root'));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}